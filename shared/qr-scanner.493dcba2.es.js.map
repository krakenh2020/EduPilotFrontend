{"version":3,"file":"qr-scanner.493dcba2.es.js","sources":["../../node_modules/qr-scanner/src/qr-scanner.js"],"sourcesContent":["export default class QrScanner {\n    /* async */\n    static hasCamera() {\n        if (!navigator.mediaDevices) return Promise.resolve(false);\n        // note that enumerateDevices can always be called and does not prompt the user for permission. However, device\n        // labels are only readable if served via https and an active media stream exists or permanent permission is\n        // given. That doesn't matter for us though as we don't require labels.\n        return navigator.mediaDevices.enumerateDevices()\n            .then(devices => devices.some(device => device.kind === 'videoinput'))\n            .catch(() => false);\n    }\n\n    constructor(\n        video,\n        onDecode,\n        canvasSizeOrOnDecodeError = this._onDecodeError.bind(this),\n        canvasSize = QrScanner.DEFAULT_CANVAS_SIZE,\n        preferredFacingMode = 'environment'\n    ) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n        this._onDecode = onDecode;\n        this._preferredFacingMode = preferredFacingMode;\n        this._active = false;\n        this._paused = false;\n        this._flashOn = false;\n\n        if (typeof canvasSizeOrOnDecodeError === 'number') {\n            // legacy function signature where canvas size is the third argument\n            canvasSize = canvasSizeOrOnDecodeError;\n            console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                + 'the future');\n        } else {\n            this._onDecodeError = canvasSizeOrOnDecodeError;\n        }\n\n        this.$canvas.width = canvasSize;\n        this.$canvas.height = canvasSize;\n        this._sourceRect = {\n            x: 0,\n            y: 0,\n            width: canvasSize,\n            height: canvasSize\n        };\n\n        this._updateSourceRect = this._updateSourceRect.bind(this);\n        this._onPlay = this._onPlay.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        this.$video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        this.$video.muted = true;\n        this.$video.disablePictureInPicture = true;\n        this.$video.addEventListener('loadedmetadata', this._updateSourceRect);\n        this.$video.addEventListener('play', this._onPlay);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n\n        this._qrEnginePromise = QrScanner.createQrEngine();\n    }\n\n    /* async */\n    hasFlash() {\n        if (!('ImageCapture' in window)) {\n            return Promise.resolve(false);\n        }\n\n        const track = this.$video.srcObject ? this.$video.srcObject.getVideoTracks()[0] : null;\n        if (!track) {\n            return Promise.reject('Camera not started or not available');\n        }\n\n        const imageCapture = new ImageCapture(track);\n        return imageCapture.getPhotoCapabilities()\n            .then((result) => {\n                return result.fillLightMode.includes('flash');\n            })\n            .catch((error) => {\n                console.warn(error);\n                return false;\n            });\n    }\n\n    isFlashOn() {\n      return this._flashOn;\n    }\n\n    /* async */\n    toggleFlash() {\n      return this._setFlash(!this._flashOn);\n    }\n\n    /* async */\n    turnFlashOff() {\n      return this._setFlash(false);\n    }\n\n    /* async */\n    turnFlashOn() {\n      return this._setFlash(true);\n    }\n\n    destroy() {\n        this.$video.removeEventListener('loadedmetadata', this._updateSourceRect);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n\n        this.stop();\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\n    }\n\n    /* async */\n    start() {\n        if (this._active && !this._paused) {\n            return Promise.resolve();\n        }\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n        this._active = true;\n        this._paused = false;\n        if (document.hidden) {\n            // camera will be started as soon as tab is in foreground\n            return Promise.resolve();\n        }\n        clearTimeout(this._offTimeout);\n        this._offTimeout = null;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            this.$video.play();\n            return Promise.resolve();\n        }\n\n        let facingMode = this._preferredFacingMode;\n        return this._getCameraStream(facingMode, true)\n            .catch(() => {\n                // We (probably) don't have a camera of the requested facing mode\n                facingMode = facingMode === 'environment' ? 'user' : 'environment';\n                return this._getCameraStream(); // throws if camera is not accessible (e.g. due to not https)\n            })\n            .then(stream => {\n                // Try to determine the facing mode from the stream, otherwise use our guess. Note that the guess is not\n                // always accurate as Safari returns cameras of different facing mode, even for exact constraints.\n                facingMode = this._getFacingMode(stream) || facingMode;\n                this.$video.srcObject = stream;\n                this.$video.play();\n                this._setVideoMirror(facingMode);\n            })\n            .catch(e => {\n                this._active = false;\n                throw e;\n            });\n    }\n\n    stop() {\n        this.pause();\n        this._active = false;\n    }\n\n    pause() {\n        this._paused = true;\n        if (!this._active) {\n            return;\n        }\n        this.$video.pause();\n        if (this._offTimeout) {\n            return;\n        }\n        this._offTimeout = setTimeout(() => {\n            const tracks = this.$video.srcObject ? this.$video.srcObject.getTracks() : [];\n            for (const track of tracks) {\n                track.stop(); //  note that this will also automatically turn the flashlight off\n            }\n            this.$video.srcObject = null;\n            this._offTimeout = null;\n        }, 300);\n    }\n\n    /* async */\n    static scanImage(imageOrFileOrUrl, sourceRect=null, qrEngine=null, canvas=null, fixedCanvasSize=false,\n                     alsoTryWithoutSourceRect=false) {\n        const gotExternalWorker = qrEngine instanceof Worker;\n\n        let promise = Promise.all([\n            qrEngine || QrScanner.createQrEngine(),\n            QrScanner._loadImage(imageOrFileOrUrl),\n        ]).then(([engine, image]) => {\n            qrEngine = engine;\n            let canvasContext;\n            [canvas, canvasContext] = this._drawToCanvas(image, sourceRect, canvas, fixedCanvasSize);\n\n            if (qrEngine instanceof Worker) {\n                if (!gotExternalWorker) {\n                    // Enable scanning of inverted color qr codes. Not using _postWorkerMessage as it's async\n                    qrEngine.postMessage({ type: 'inversionMode', data: 'both' });\n                }\n                return new Promise((resolve, reject) => {\n                    let timeout, onMessage, onError;\n                    onMessage = event => {\n                        if (event.data.type !== 'qrResult') {\n                            return;\n                        }\n                        qrEngine.removeEventListener('message', onMessage);\n                        qrEngine.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        if (event.data.data !== null) {\n                            resolve(event.data.data);\n                        } else {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        }\n                    };\n                    onError = (e) => {\n                        qrEngine.removeEventListener('message', onMessage);\n                        qrEngine.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        const errorMessage = !e ? 'Unknown Error' : (e.message || e);\n                        reject('Scanner error: ' + errorMessage);\n                    };\n                    qrEngine.addEventListener('message', onMessage);\n                    qrEngine.addEventListener('error', onError);\n                    timeout = setTimeout(() => onError('timeout'), 10000);\n                    const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);\n                    qrEngine.postMessage({\n                        type: 'decode',\n                        data: imageData\n                    }, [imageData.data.buffer]);\n                });\n            } else {\n                return new Promise((resolve, reject) => {\n                    const timeout = setTimeout(() => reject('Scanner error: timeout'), 10000);\n                    qrEngine.detect(canvas).then(scanResults => {\n                        if (!scanResults.length) {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        } else {\n                            resolve(scanResults[0].rawValue);\n                        }\n                    }).catch((e) => reject('Scanner error: ' + (e.message || e))).finally(() => clearTimeout(timeout));\n                });\n            }\n        });\n\n        if (sourceRect && alsoTryWithoutSourceRect) {\n            promise = promise.catch(() => QrScanner.scanImage(imageOrFileOrUrl, null, qrEngine, canvas, fixedCanvasSize));\n        }\n\n        promise = promise.finally(() => {\n            if (gotExternalWorker) return;\n            QrScanner._postWorkerMessage(qrEngine, 'close');\n        });\n\n        return promise;\n    }\n\n    setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations work also\n        // well with colored qr codes.\n        QrScanner._postWorkerMessage(\n            this._qrEnginePromise,\n            'grayscaleWeights',\n            { red, green, blue, useIntegerApproximation }\n        );\n    }\n\n    setInversionMode(inversionMode) {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations scan normal\n        // and inverted qr codes by default\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\n    }\n\n    /* async */\n    static createQrEngine(workerPath = QrScanner.WORKER_PATH) {\n        return ('BarcodeDetector' in window ? BarcodeDetector.getSupportedFormats() : Promise.resolve([]))\n            .then((supportedFormats) => supportedFormats.indexOf('qr_code') !== -1\n                ? new BarcodeDetector({ formats: ['qr_code'] })\n                : new Worker(workerPath)\n            );\n    }\n\n    _onPlay() {\n        this._updateSourceRect();\n        this._scanFrame();\n    }\n\n    _onVisibilityChange() {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    _updateSourceRect() {\n        const smallestDimension = Math.min(this.$video.videoWidth, this.$video.videoHeight);\n        const sourceRectSize = Math.round(2 / 3 * smallestDimension);\n        this._sourceRect.width = this._sourceRect.height = sourceRectSize;\n        this._sourceRect.x = (this.$video.videoWidth - sourceRectSize) / 2;\n        this._sourceRect.y = (this.$video.videoHeight - sourceRectSize) / 2;\n    }\n\n    _scanFrame() {\n        if (!this._active || this.$video.paused || this.$video.ended) return false;\n        // using requestAnimationFrame to avoid scanning if tab is in background\n        requestAnimationFrame(() => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n            this._qrEnginePromise\n                .then((qrEngine) => QrScanner.scanImage(this.$video, this._sourceRect, qrEngine, this.$canvas, true))\n                .then(this._onDecode, (error) => {\n                    if (!this._active) return;\n                    const errorMessage = error.message || error;\n                    if (errorMessage.indexOf('service unavailable') !== -1) {\n                        // When the native BarcodeDetector crashed, create a new one\n                        this._qrEnginePromise = QrScanner.createQrEngine();\n                    }\n                    this._onDecodeError(error);\n                })\n                .then(() => this._scanFrame());\n        });\n    }\n\n    _onDecodeError(error) {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    _getCameraStream(facingMode, exact = false) {\n        const constraintsToTry = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n\n        if (facingMode) {\n            if (exact) {\n                facingMode = { exact: facingMode };\n            }\n            constraintsToTry.forEach(constraint => constraint.facingMode = facingMode);\n        }\n        return this._getMatchingCameraStream(constraintsToTry);\n    }\n\n    _getMatchingCameraStream(constraintsToTry) {\n        if (!navigator.mediaDevices || constraintsToTry.length === 0) {\n            return Promise.reject('Camera not found.');\n        }\n        return navigator.mediaDevices.getUserMedia({\n            video: constraintsToTry.shift()\n        }).catch(() => this._getMatchingCameraStream(constraintsToTry));\n    }\n\n    /* async */\n    _setFlash(on) {\n        return this.hasFlash().then((hasFlash) => {\n            if (!hasFlash) return Promise.reject('No flash available');\n            // Note that the video track is guaranteed to exist at this point\n            return this.$video.srcObject.getVideoTracks()[0].applyConstraints({\n                advanced: [{ torch: on }],\n            });\n        }).then(() => this._flashOn = on);\n    }\n\n    _setVideoMirror(facingMode) {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode==='user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    _getFacingMode(videoStream) {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    static _drawToCanvas(image, sourceRect=null, canvas=null, fixedCanvasSize=false) {\n        canvas = canvas || document.createElement('canvas');\n        const sourceRectX = sourceRect && sourceRect.x? sourceRect.x : 0;\n        const sourceRectY = sourceRect && sourceRect.y? sourceRect.y : 0;\n        const sourceRectWidth = sourceRect && sourceRect.width? sourceRect.width : image.width || image.videoWidth;\n        const sourceRectHeight = sourceRect && sourceRect.height? sourceRect.height : image.height || image.videoHeight;\n        if (!fixedCanvasSize && (canvas.width !== sourceRectWidth || canvas.height !== sourceRectHeight)) {\n            canvas.width = sourceRectWidth;\n            canvas.height = sourceRectHeight;\n        }\n        const context = canvas.getContext('2d', { alpha: false });\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(image, sourceRectX, sourceRectY, sourceRectWidth, sourceRectHeight, 0, 0, canvas.width, canvas.height);\n        return [canvas, context];\n    }\n\n    /* async */\n    static _loadImage(imageOrFileOrBlobOrUrl) {\n        if (imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement || imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || window.ImageBitmap && imageOrFileOrBlobOrUrl instanceof window.ImageBitmap\n            || window.OffscreenCanvas && imageOrFileOrBlobOrUrl instanceof window.OffscreenCanvas) {\n            return Promise.resolve(imageOrFileOrBlobOrUrl);\n        } else if (imageOrFileOrBlobOrUrl instanceof Image) {\n            return QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl).then(() => imageOrFileOrBlobOrUrl);\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof(imageOrFileOrBlobOrUrl)==='string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl;\n            }\n            return QrScanner._awaitImageLoad(image).then(() => {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n                return image;\n            });\n        } else {\n            return Promise.reject('Unsupported image type.');\n        }\n    }\n\n    /* async */\n    static _awaitImageLoad(image) {\n        return new Promise((resolve, reject) => {\n            if (image.complete && image.naturalWidth!==0) {\n                // already loaded\n                resolve();\n            } else {\n                let onLoad, onError;\n                onLoad = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    resolve();\n                };\n                onError = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    reject('Image load error');\n                };\n                image.addEventListener('load', onLoad);\n                image.addEventListener('error', onError);\n            }\n        });\n    }\n\n    /* async */\n    static _postWorkerMessage(qrEngineOrQrEnginePromise, type, data) {\n        return Promise.resolve(qrEngineOrQrEnginePromise).then((qrEngine) => {\n            if (!(qrEngine instanceof Worker)) return;\n            qrEngine.postMessage({ type, data });\n        });\n    }\n}\nQrScanner.DEFAULT_CANVAS_SIZE = 400;\nQrScanner.NO_QR_CODE_FOUND = 'No QR code found';\nQrScanner.WORKER_PATH = 'qr-scanner-worker.min.js';\n"],"names":["QrScanner","navigator","mediaDevices","enumerateDevices","then","devices","some","device","kind","catch","Promise","resolve","constructor","video","onDecode","canvasSizeOrOnDecodeError","this","_onDecodeError","bind","canvasSize","DEFAULT_CANVAS_SIZE","preferredFacingMode","$video","$canvas","document","createElement","_onDecode","_preferredFacingMode","_active","_paused","_flashOn","console","warn","width","height","_sourceRect","x","y","_updateSourceRect","_onPlay","_onVisibilityChange","playsInline","muted","disablePictureInPicture","addEventListener","_qrEnginePromise","createQrEngine","hasFlash","window","track","srcObject","getVideoTracks","reject","ImageCapture","getPhotoCapabilities","result","fillLightMode","includes","error","isFlashOn","toggleFlash","_setFlash","turnFlashOff","turnFlashOn","destroy","removeEventListener","stop","_postWorkerMessage","start","location","protocol","hidden","clearTimeout","_offTimeout","play","facingMode","_getCameraStream","stream","_getFacingMode","_setVideoMirror","e","pause","setTimeout","tracks","getTracks","imageOrFileOrUrl","sourceRect","qrEngine","canvas","fixedCanvasSize","alsoTryWithoutSourceRect","gotExternalWorker","Worker","promise","all","_loadImage","engine","image","canvasContext","_drawToCanvas","postMessage","type","data","timeout","onMessage","onError","event","NO_QR_CODE_FOUND","errorMessage","message","imageData","getImageData","buffer","detect","scanResults","length","rawValue","finally","scanImage","setGrayscaleWeights","red","green","blue","useIntegerApproximation","setInversionMode","inversionMode","workerPath","WORKER_PATH","BarcodeDetector","getSupportedFormats","supportedFormats","indexOf","formats","_scanFrame","smallestDimension","Math","min","videoWidth","videoHeight","sourceRectSize","round","paused","ended","requestAnimationFrame","readyState","log","exact","constraintsToTry","forEach","constraint","_getMatchingCameraStream","getUserMedia","shift","on","applyConstraints","advanced","torch","scaleFactor","style","transform","videoStream","videoTrack","test","label","sourceRectX","sourceRectY","sourceRectWidth","sourceRectHeight","context","getContext","alpha","imageSmoothingEnabled","drawImage","imageOrFileOrBlobOrUrl","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","OffscreenCanvas","Image","_awaitImageLoad","File","Blob","URL","src","createObjectURL","revokeObjectURL","complete","naturalWidth","onLoad","qrEngineOrQrEnginePromise"],"mappings":"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"}